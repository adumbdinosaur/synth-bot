<!-- Session JavaScript Functions Component -->
<script>
    function resetDefaults() {
        // Default energy costs based on message type
        const defaults = {
            'text_cost': 1,
            'photo_cost': 3,
            'video_cost': 5,
            'audio_cost': 4,
            'voice_cost': 2,
            'document_cost': 3,
            'sticker_cost': 1,
            'animation_cost': 3,
            'gif_cost': 4,
            'location_cost': 2,
            'contact_cost': 2,
            'poll_cost': 3,
            'game_cost': 3,
            'venue_cost': 2,
            'web_page_cost': 2,
            'media_group_cost': 5
        };

        if (confirm('Are you sure you want to reset all energy costs to default values?')) {
            Object.keys(defaults).forEach(key => {
                const input = document.getElementById(key);
                if (input) {
                    input.value = defaults[key];
                }
            });
        }
    }

    function saveAllEnergyCosts() {
        if (!confirm('Save all energy cost changes?')) {
            return;
        }

        // Collect all current values from individual forms
        const costData = {};
        const forms = document.querySelectorAll('.individual-cost-form');

        forms.forEach(form => {
            const messageType = form.querySelector('input[name="message_type"]').value;
            const energyCost = form.querySelector('input[name="energy_cost"]').value;
            costData[messageType + '_cost'] = energyCost;
        });

        // Create a form data object
        const formData = new FormData();
        Object.keys(costData).forEach(key => {
            formData.append(key, costData[key]);
        });

        // Submit to bulk endpoint
        fetch(`/public/api/sessions/${getCurrentUserId()}/energy-costs`, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert('All energy costs saved successfully!', 'success');
                } else {
                    showAlert(data.error || 'Failed to save all energy costs', 'danger');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showAlert('An error occurred while saving all energy costs.', 'danger');
            });
    }

    function clearAllBadwords() {
        if (!confirm('Are you sure you want to remove ALL badwords? This action cannot be undone.')) {
            return;
        }

        fetch(`/public/api/sessions/${getCurrentUserId()}/badwords/clear-all`, {
            method: 'POST',
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert('All badwords cleared successfully!', 'success');
                    // Remove all badword rows from the table
                    const tableBody = document.querySelector('tbody');
                    if (tableBody) {
                        tableBody.innerHTML = '';
                    }
                    // Show the "no badwords" message
                    const tableContainer = document.querySelector('.table-responsive');
                    if (tableContainer) {
                        tableContainer.innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle"></i>
                            No badwords configured for this user. Add some above to enable message filtering.
                        </div>
                    `;
                    }
                } else {
                    showAlert(data.error || 'Failed to clear all badwords', 'danger');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showAlert('An error occurred while clearing badwords.', 'danger');
            });
    }

    function clearAllWhitelistWords() {
        if (!confirm('Are you sure you want to remove ALL whitelist words? This action cannot be undone.')) {
            return;
        }

        fetch(`/public/api/sessions/${getCurrentUserId()}/whitelist-words/clear-all`, {
            method: 'POST',
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert('All whitelist words cleared successfully!', 'success');
                    // Remove all whitelist word rows from the table
                    const whitelistTableBody = document.querySelector('#whitelistWordsCollapse tbody');
                    if (whitelistTableBody) {
                        whitelistTableBody.innerHTML = '';
                    }
                    // Show the "no whitelist words" message
                    const whitelistTableContainer = document.querySelector('#whitelistWordsCollapse .table-responsive');
                    if (whitelistTableContainer) {
                        whitelistTableContainer.innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle"></i>
                            No whitelist words configured for this user. Add some above to allow specific messages even when power is 0.
                        </div>
                    `;
                    }
                } else {
                    showAlert(data.error || 'Failed to clear all whitelist words', 'danger');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showAlert('An error occurred while clearing whitelist words.', 'danger');
            });
    }

    // Auto-dismiss alerts after 5 seconds
    setTimeout(function () {
        const alerts = document.querySelectorAll('.alert');
        alerts.forEach(alert => {
            if (alert.classList.contains('show')) {
                const bsAlert = new bootstrap.Alert(alert);
                bsAlert.close();
            }
        });
    }, 5000);

    // Handle collapsible section toggle icons
    document.addEventListener('DOMContentLoaded', function () {
        // Add event listeners for all collapsible sections
        const collapseElements = document.querySelectorAll('.collapse');

        collapseElements.forEach(function (collapseEl) {
            const toggleIcon = collapseEl.previousElementSibling.querySelector('.collapse-toggle');

            collapseEl.addEventListener('show.bs.collapse', function () {
                if (toggleIcon) {
                    toggleIcon.classList.remove('collapsed');
                }
            });

            collapseEl.addEventListener('hide.bs.collapse', function () {
                if (toggleIcon) {
                    toggleIcon.classList.add('collapsed');
                }
            });
        });

        // Convert all forms to AJAX to prevent page refreshes
        setupAjaxForms();
    });

    function setupAjaxForms() {
        const forms = document.querySelectorAll('form');

        forms.forEach(form => {
            form.addEventListener('submit', function (e) {
                e.preventDefault(); // Prevent default form submission

                const formData = new FormData(form);
                const button = form.querySelector('button[type="submit"]');
                const originalContent = button.innerHTML;

                // Show loading state
                button.disabled = true;
                button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

                // Convert to JSON API endpoint
                const apiAction = convertToApiEndpoint(form.action);

                fetch(apiAction, {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showAlert(data.message, 'success');
                            updateUIAfterFormSubmission(form, data);
                        } else {
                            showAlert(data.error || 'An error occurred', 'danger');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        showAlert('An error occurred while processing your request.', 'danger');
                    })
                    .finally(() => {
                        // Restore button state
                        button.disabled = false;
                        button.innerHTML = originalContent;
                    });
            });
        });
    }

    function convertToApiEndpoint(originalAction) {
        // Convert form action to JSON API endpoint
        // /public/sessions/123/energy/add -> /public/api/sessions/123/energy/add
        return originalAction.replace('/public/sessions/', '/public/api/sessions/');
    }

    function updateUIAfterFormSubmission(form, responseData) {
        const action = form.action;

        if (action.includes('/recharge-rate')) {
            // Update recharge rate displays
            updateRechargeRateDisplay(responseData.recharge_rate);
        } else if (action.includes('/energy/')) {
            // Update energy displays
            updateEnergyDisplays(responseData.energy, responseData.max_energy);
        } else if (action.includes('/badwords/add')) {
            // Add new badword to the list
            addBadwordToList(responseData.word, responseData.penalty);
            // Clear the form
            form.reset();
        } else if (action.includes('/badwords/remove')) {
            // Remove badword from the list
            removeBadwordFromList(responseData.word);
        } else if (action.includes('/badwords/update')) {
            // Update badword penalty in the list
            updateBadwordInList(responseData.word, responseData.penalty);
        } else if (action.includes('/autocorrect')) {
            // Update autocorrect toggle display
            if (responseData.enabled !== undefined) {
                updateAutocorrectDisplay(responseData.enabled);
            }
        } else if (action.includes('/energy-costs')) {
            // Update energy cost inputs - they're already updated by the form
            // No additional UI updates needed as the form inputs contain the latest values
        } else if (action.includes('/profile/revert-cost')) {
            // Update profile revert cost display
            updateProfileRevertCostDisplay(responseData.revert_cost);
        } else if (action.includes('/timer/')) {
            // Update timer displays
            if (responseData.timer_info) {
                updateTimerDisplays(responseData.timer_info);
            }
        }
    }

    function updateRechargeRateDisplay(newRate) {
        // Update the recharge rate in the overview cards
        const overviewCards = document.querySelectorAll('.col-md-4 .card .card-body');
        overviewCards.forEach(card => {
            const h3 = card.querySelector('h3');
            const small = card.querySelector('small');
            if (small && small.textContent.includes('Energy/Minute')) {
                h3.textContent = newRate;
            }
        });

        // Update recharge rate in energy management info
        const rechargeText = document.querySelector('.card-text.text-muted');
        if (rechargeText && rechargeText.textContent.includes('Recharge Rate:')) {
            rechargeText.textContent = `Recharge Rate: ${newRate || 1} energy per minute`;
        }
    }

    function updateEnergyDisplays(energy, maxEnergy) {
        // Calculate percentage
        const percentage = Math.round((energy / maxEnergy) * 100);

        // Update overview card
        const overviewCards = document.querySelectorAll('.col-md-4 .card .card-body');
        overviewCards.forEach(card => {
            const h3 = card.querySelector('h3');
            const small = card.querySelector('small');
            if (small && small.textContent.includes('Current Energy')) {
                h3.textContent = energy;
            }
        });

        // Update current energy display in energy management section
        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) {
            progressBar.style.width = percentage + '%';
            progressBar.textContent = `${energy}/${maxEnergy}`;

            // Update color based on percentage
            progressBar.className = 'progress-bar bg-' +
                (percentage > 70 ? 'success' : percentage > 30 ? 'warning' : 'danger');
        }

        // Update battery icon
        const batteryIcon = document.querySelector('.fa-battery-full, .fa-battery-three-quarters, .fa-battery-half, .fa-battery-quarter, .fa-battery-empty');
        if (batteryIcon) {
            // Remove old battery classes
            batteryIcon.className = batteryIcon.className.replace(/fa-battery-\w+/g, '');

            // Add new battery class
            let batteryClass = 'fa-battery-';
            if (percentage > 75) batteryClass += 'full';
            else if (percentage > 50) batteryClass += 'three-quarters';
            else if (percentage > 25) batteryClass += 'half';
            else if (percentage > 10) batteryClass += 'quarter';
            else batteryClass += 'empty';

            batteryIcon.classList.add(batteryClass);

            // Update color
            const colorClass = percentage > 70 ? 'text-success' : percentage > 30 ? 'text-warning' : 'text-danger';
            batteryIcon.className = batteryIcon.className.replace(/text-(success|warning|danger)/g, '') + ' ' + colorClass;
        }

        // Update input max values for remove energy form
        const removeAmountInput = document.getElementById('remove_amount');
        if (removeAmountInput) {
            removeAmountInput.max = energy;
        }
    }

    function showAlert(message, type) {
        // Remove existing alerts
        const existingAlerts = document.querySelectorAll('.alert:not(.alert-dismissible)');
        existingAlerts.forEach(alert => alert.remove());

        // Create new alert
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
        alertDiv.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-triangle'}"></i> ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;

        // Insert at the top of the container
        const container = document.querySelector('.container');
        const header = container.querySelector('.d-flex.justify-content-between');
        header.insertAdjacentElement('afterend', alertDiv);

        // Auto-dismiss after 3 seconds
        setTimeout(() => {
            if (alertDiv && alertDiv.parentNode) {
                const bsAlert = new bootstrap.Alert(alertDiv);
                bsAlert.close();
            }
        }, 3000);
    }

    function addBadwordToList(word, penalty) {
        // Find the badwords list container
        const badwordsList = document.querySelector('#badwordsList, .badwords-list');
        if (!badwordsList) return;

        // Create new badword item
        const badwordItem = document.createElement('div');
        badwordItem.className = 'list-group-item d-flex justify-content-between align-items-center';
        badwordItem.innerHTML = `
            <div>
                <strong>${escapeHtml(word)}</strong>
                <span class="badge bg-danger ms-2">${penalty} energy</span>
            </div>
            <div>
                <form method="POST" action="/public/sessions/${getCurrentUserId()}/badwords/update" class="d-inline me-2">
                    <input type="hidden" name="word" value="${escapeHtml(word)}">
                    <div class="input-group input-group-sm" style="width: 120px;">
                        <input type="number" name="penalty" class="form-control" value="${penalty}" min="1" max="100">
                        <button type="submit" class="btn btn-outline-warning btn-sm">
                            <i class="fas fa-edit"></i>
                        </button>
                    </div>
                </form>
                <form method="POST" action="/public/sessions/${getCurrentUserId()}/badwords/remove" class="d-inline">
                    <input type="hidden" name="word" value="${escapeHtml(word)}">
                    <button type="submit" class="btn btn-outline-danger btn-sm">
                        <i class="fas fa-trash"></i>
                    </button>
                </form>
            </div>
        `;

        // Add to the list
        badwordsList.appendChild(badwordItem);

        // Setup AJAX for the new forms
        setupAjaxForElement(badwordItem);
    }

    function removeBadwordFromList(word) {
        // Find and remove the badword item
        const badwordItems = document.querySelectorAll('.list-group-item');
        badwordItems.forEach(item => {
            const wordElement = item.querySelector('strong');
            if (wordElement && wordElement.textContent === word) {
                item.remove();
            }
        });
    }

    function updateBadwordInList(word, penalty) {
        // Find and update the badword penalty
        const badwordItems = document.querySelectorAll('.list-group-item');
        badwordItems.forEach(item => {
            const wordElement = item.querySelector('strong');
            if (wordElement && wordElement.textContent === word) {
                const badge = item.querySelector('.badge');
                if (badge) {
                    badge.textContent = `${penalty} energy`;
                }
                const penaltyInput = item.querySelector('input[name="penalty"]');
                if (penaltyInput) {
                    penaltyInput.value = penalty;
                }
            }
        });
    }

    function updateAutocorrectDisplay(enabled) {
        // Update autocorrect toggle switch/checkbox
        const autocorrectToggle = document.querySelector('input[name="enabled"]');
        if (autocorrectToggle) {
            if (autocorrectToggle.type === 'checkbox') {
                autocorrectToggle.checked = enabled;
            } else {
                autocorrectToggle.value = enabled ? 'true' : 'false';
            }
        }

        // Update any status displays
        const statusElements = document.querySelectorAll('.autocorrect-status');
        statusElements.forEach(el => {
            el.textContent = enabled ? 'Enabled' : 'Disabled';
            el.className = `autocorrect-status badge bg-${enabled ? 'success' : 'secondary'}`;
        });
    }

    function setupAjaxForElement(element) {
        // Setup AJAX for forms within a specific element
        const forms = element.querySelectorAll('form');
        forms.forEach(form => {
            form.addEventListener('submit', function (e) {
                e.preventDefault();

                const formData = new FormData(form);
                const button = form.querySelector('button[type="submit"]');
                const originalContent = button.innerHTML;

                button.disabled = true;
                button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                const apiAction = convertToApiEndpoint(form.action);

                fetch(apiAction, {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showAlert(data.message, 'success');
                            updateUIAfterFormSubmission(form, data);
                        } else {
                            showAlert(data.error || 'An error occurred', 'danger');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        showAlert('An error occurred while processing your request.', 'danger');
                    })
                    .finally(() => {
                        button.disabled = false;
                        button.innerHTML = originalContent;
                    });
            });
        });
    }

    function getCurrentUserId() {
        // Extract user ID from current URL
        const pathParts = window.location.pathname.split('/');
        return pathParts[pathParts.length - 1];
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function updateProfileRevertCostDisplay(revertCost) {
        // Update profile revert cost input
        const revertCostInput = document.querySelector('input[name="revert_cost"]');
        if (revertCostInput) {
            revertCostInput.value = revertCost;
        }

        // Update any display elements showing the revert cost
        const revertCostDisplays = document.querySelectorAll('.revert-cost-display');
        revertCostDisplays.forEach(el => {
            el.textContent = revertCost;
        });
    }

    function updateTimerDisplays(timerInfo) {
        // Update timer end time display
        const timerEndDisplay = document.querySelector('input[name="timer_end"]');
        if (timerEndDisplay && timerInfo.timer_end) {
            timerEndDisplay.value = timerInfo.timer_end.substring(0, 16);
        }

        // Update countdown display if it exists
        const countdownElement = document.getElementById('countdown-timer');
        if (countdownElement && timerInfo.remaining_seconds !== undefined) {
            // The timer countdown script will handle the update automatically
            // We might need to restart the countdown with new remaining time
            if (window.updateCountdownWithNewTime) {
                window.updateCountdownWithNewTime(timerInfo.remaining_seconds);
            }
        }

        // If timer was just created, reload page to show timer management instead of creation
        if (timerInfo.has_timer && !document.querySelector('#timerManagementCollapse')) {
            showAlert('Timer created successfully! Refreshing page...', 'success');
            setTimeout(() => {
                window.location.reload();
            }, 1500);
        }
    }

    // Timer Creation Functions
    function createTimerWithDuration(minutes) {
        const now = new Date();
        const endTime = new Date(now.getTime() + (minutes * 60 * 1000));

        // Create ISO string for the form
        const timerEnd = endTime.toISOString().substring(0, 16);

        // Create form data
        const formData = new FormData();
        formData.append('timer_end', timerEnd);

        const userId = getCurrentUserId();

        showAlert(`Creating timer for ${minutes} minutes...`, 'info');

        // Submit via AJAX
        fetch(`/public/api/sessions/${userId}/timer/create`, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert(data.message, 'success');
                    updateTimerDisplays(data.timer_info);
                } else {
                    showAlert(data.error || 'Failed to create timer', 'danger');
                }
            })
            .catch(error => {
                console.error('Error creating timer:', error);
                showAlert('An error occurred while creating the timer', 'danger');
            });
    }

    function handleTimerCreationForm(event) {
        event.preventDefault();

        const form = event.target;
        const formData = new FormData(form);
        const userId = getCurrentUserId();

        const button = form.querySelector('button[type="submit"]');
        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating Timer...';

        // Submit via AJAX
        fetch(`/public/api/sessions/${userId}/timer/create`, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showAlert(data.message, 'success');
                    updateTimerDisplays(data.timer_info);
                } else {
                    showAlert(data.error || 'Failed to create timer', 'danger');
                }
            })
            .catch(error => {
                console.error('Error creating timer:', error);
                showAlert('An error occurred while creating the timer', 'danger');
            })
            .finally(() => {
                // Restore button state
                button.disabled = false;
                button.innerHTML = originalContent;
            });
    }

    // Custom Redactions Management Functions
    function addCustomRedaction(event) {
        event.preventDefault();

        const formData = new FormData(event.target);
        const userId = getCurrentUserId();

        // Debug: Log form data
        console.log('Form data being sent:');
        for (let [key, value] of formData.entries()) {
            console.log(key, value);
        }
        console.log('User ID:', userId);
        console.log('URL:', `/public/sessions/${userId}/custom_redactions`);

        const button = event.target.querySelector('button[type="submit"]');
        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';

        fetch(`/public/sessions/${userId}/custom_redactions`, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin'
        })
            .then(response => {
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Add new row to table
                    addRedactionToTable(data.redaction);
                    // Clear form
                    event.target.reset();
                    // Show success message
                    showAlert('Custom redaction added successfully!', 'success');
                } else {
                    showAlert(data.error || 'Failed to add custom redaction', 'danger');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showAlert('Error adding custom redaction', 'danger');
            })
            .finally(() => {
                button.disabled = false;
                button.innerHTML = originalContent;
            });
    }

    function addRedactionToTable(redaction) {
        const tbody = document.getElementById('customRedactionsList');
        const row = document.createElement('tr');
        row.setAttribute('data-original-word', redaction.original_word);

        const createdAt = redaction.created_at ? new Date(redaction.created_at).toLocaleString() : 'Just now';

        row.innerHTML = `
            <td><code>${escapeHtml(redaction.original_word)}</code></td>
            <td><span class="badge bg-info">${escapeHtml(redaction.replacement_word)}</span></td>
            <td><span class="badge bg-warning">-${redaction.penalty}</span></td>
            <td>${redaction.case_sensitive ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-muted"></i>'}</td>
            <td><small class="text-muted">${createdAt}</small></td>
            <td>
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-primary btn-sm edit-redaction-btn" 
                            data-original-word="${redaction.original_word}"
                            data-replacement-word="${redaction.replacement_word}"
                            data-penalty="${redaction.penalty}"
                            data-case-sensitive="${redaction.case_sensitive}">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button type="button" class="btn btn-outline-danger btn-sm remove-redaction-btn" 
                            data-original-word="${redaction.original_word}">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </td>
        `;

        tbody.appendChild(row);

        // Hide "no redactions" message if it exists
        const noRedactionsAlert = tbody.parentElement.parentElement.querySelector('.alert-info');
        if (noRedactionsAlert) {
            noRedactionsAlert.style.display = 'none';
        }
    }

    function removeCustomRedaction(originalWord) {
        if (!confirm(`Are you sure you want to remove the redaction for "${originalWord}"?`)) {
            return;
        }

        const userId = getCurrentUserId();

        fetch(`/public/sessions/${userId}/custom_redactions/${encodeURIComponent(originalWord)}`, {
            method: 'DELETE',
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove row from table
                    const row = document.querySelector(`tr[data-original-word="${originalWord}"]`);
                    if (row) {
                        row.remove();
                    }
                    showAlert('Custom redaction removed successfully!', 'success');

                    // Show "no redactions" message if table is empty
                    const tbody = document.getElementById('customRedactionsList');
                    if (tbody.children.length === 0) {
                        const noRedactionsAlert = tbody.parentElement.parentElement.querySelector('.alert-info');
                        if (noRedactionsAlert) {
                            noRedactionsAlert.style.display = 'block';
                        }
                    }
                } else {
                    showAlert(data.error || 'Failed to remove custom redaction', 'danger');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showAlert('Error removing custom redaction', 'danger');
            });
    }

    function editCustomRedaction(originalWord, replacementWord, penalty, caseSensitive) {
        document.getElementById('editOriginalWord').value = originalWord;
        document.getElementById('editReplacementWord').value = replacementWord;
        document.getElementById('editRedactionPenalty').value = penalty;

        const modal = new bootstrap.Modal(document.getElementById('editCustomRedactionModal'));
        modal.show();
    }

    function updateCustomRedaction() {
        const form = document.getElementById('editCustomRedactionForm');
        const formData = new FormData(form);
        const userId = getCurrentUserId();
        const originalWord = formData.get('originalWord');

        fetch(`/public/sessions/${userId}/custom_redactions/${encodeURIComponent(originalWord)}`, {
            method: 'PUT',
            body: formData,
            credentials: 'same-origin'
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the row in the table
                    const row = document.querySelector(`tr[data-original-word="${originalWord}"]`);
                    if (row) {
                        const replacementCell = row.querySelector('td:nth-child(2)');
                        const penaltyCell = row.querySelector('td:nth-child(3)');

                        replacementCell.innerHTML = `<span class="badge bg-info">${escapeHtml(data.redaction.replacement_word)}</span>`;
                        penaltyCell.innerHTML = `<span class="badge bg-warning">-${data.redaction.penalty}</span>`;

                        // Update button data attributes
                        const editBtn = row.querySelector('.edit-redaction-btn');
                        editBtn.setAttribute('data-replacement-word', data.redaction.replacement_word);
                        editBtn.setAttribute('data-penalty', data.redaction.penalty);
                    }

                    showAlert('Custom redaction updated successfully!', 'success');

                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editCustomRedactionModal'));
                    modal.hide();
                } else {
                    showAlert(data.error || 'Failed to update custom redaction', 'danger');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showAlert('Error updating custom redaction', 'danger');
            });
    }

    // Event Listeners for Custom Redactions
    document.addEventListener('DOMContentLoaded', function () {
        // Add custom redaction form
        const addForm = document.getElementById('addCustomRedactionForm');
        if (addForm) {
            addForm.addEventListener('submit', addCustomRedaction);
        }

        // Timer creation form
        const timerCreationForm = document.querySelector('form[action*="/timer/create"]');
        if (timerCreationForm) {
            timerCreationForm.addEventListener('submit', handleTimerCreationForm);
        }

        // Edit redaction buttons
        document.addEventListener('click', function (e) {
            if (e.target.closest('.edit-redaction-btn')) {
                const btn = e.target.closest('.edit-redaction-btn');
                const originalWord = btn.getAttribute('data-original-word');
                const replacementWord = btn.getAttribute('data-replacement-word');
                const penalty = btn.getAttribute('data-penalty');
                const caseSensitive = btn.getAttribute('data-case-sensitive') === 'true';

                editCustomRedaction(originalWord, replacementWord, penalty, caseSensitive);
            }
        });

        // Remove redaction buttons
        document.addEventListener('click', function (e) {
            if (e.target.closest('.remove-redaction-btn')) {
                const btn = e.target.closest('.remove-redaction-btn');
                const originalWord = btn.getAttribute('data-original-word');
                removeCustomRedaction(originalWord);
            }
        });
    });
</script>